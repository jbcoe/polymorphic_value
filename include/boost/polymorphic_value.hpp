// Copyright (c) 2016 Jonathan B. Coe
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef BOOST_POLYMORPHIC_VALUE_12JUL2018_HPP
#define BOOST_POLYMORPHIC_VALUE_12JUL2018_HPP

#include <cassert>
#include <exception>
#include <memory>
#include <type_traits>
#include <typeinfo>

namespace boost {

  template <class T>
  class polymorphic_value;

  template <class T>
  struct default_copy {
    /**
     * _Returns_:  `new T(t)`.
     */
    T* operator()(const T& t) const { return new T(t); }
  };

  ////////////////////////////////////////////////////////////////////////////
  // Implementation detail classes
  ////////////////////////////////////////////////////////////////////////////

  namespace detail {

    struct private_ctor_tag_t {};
    constexpr private_ctor_tag_t private_ctor_tag;

    template <class T>
    struct control_block {
      virtual ~control_block() = default;

      virtual std::unique_ptr<control_block> clone() const = 0;

      virtual T* ptr() = 0;
    };

    template <class T, class U = T>
    class direct_control_block : public control_block<T> {
      U u_;

    public:
      template <class... Ts>
      explicit direct_control_block(Ts&&... ts)
          : u_(U(std::forward<Ts>(ts)...)) {}

      std::unique_ptr<control_block<T>> clone() const override {
        return std::make_unique<direct_control_block>(*this);
      }

      T* ptr() override { return &u_; }
    };

    template <class T, class U, class C = default_copy<U>,
              class D = std::default_delete<U>>
    class pointer_control_block : public control_block<T>, public C {
      std::unique_ptr<U, D> p_;

    public:
      explicit pointer_control_block(U* u, C c = C{}, D d = D{})
          : C(std::move(c)), p_(u, std::move(d)) {}

      explicit pointer_control_block(std::unique_ptr<U, D> p, C c = C{})
          : C(std::move(c)), p_(std::move(p)) {}

      std::unique_ptr<control_block<T>> clone() const override {
        assert(p_);
        return std::make_unique<pointer_control_block>(
            C::operator()(*p_), static_cast<const C&>(*this), p_.get_deleter());
      }

      T* ptr() override { return p_.get(); }
    };

    template <class T, class U>
    class delegating_control_block : public control_block<T> {
      std::unique_ptr<control_block<U>> delegate_;

    public:
      explicit delegating_control_block(std::unique_ptr<control_block<U>> b)
          : delegate_(std::move(b)) {}

      std::unique_ptr<control_block<T>> clone() const override {
        return std::make_unique<delegating_control_block>(delegate_->clone());
      }

      T* ptr() override { return delegate_->ptr(); }
    };

    template <class T>
    struct is_polymorphic_value : std::false_type {};

    template <class T>
    struct is_polymorphic_value<polymorphic_value<T>> : std::true_type {};

  } // namespace detail

  class bad_polymorphic_value_construction : std::exception {
  public:
    /**
     * _Effects_: Constructs a `bad_polymorphic_value_construction` object.
     */
    bad_polymorphic_value_construction() noexcept = default;

    /**
     * _Returns_: An implementation-defined NTBS.
     */
    const char* what() const noexcept override {
      return "Dynamic and static type mismatch in polymorphic_value "
             "construction";
    }
  };

  ////////////////////////////////////////////////////////////////////////////////
  // `polymorphic_value` class definition
  ////////////////////////////////////////////////////////////////////////////////

  /**
   * A `polymorphic_value` is an object that owns another object.
   * The `polymorphic_value` is responsible for the lifetime management of the
   * owned object and will dispose of the owned object when the
   * polymorphic_value's lifetime ends.
   *
   * A `polymorphic_value` object is empty if it does not own an object.
   *
   * Copying a non-empty `polymorphic_value` will copy the owned object so that
   * the copied `polymorphic_value` will have its own unique copy of the owned
   * object.
   *
   * Copying from an empty `polymorphic_value` produces another empty
   * `polymorphic_value`.
   *
   * Copying and disposal of the owned object can be customized by supplying a
   * copier and deleter.
   *
   * If a `polymorphic_value` is constructed from a pointer then it is said to
   * have a custom copier and deleter. Any `polymorphic_value` instance
   * constructed from another `polymorphic_value` instance constructed with a
   * custom copier and deleter will also have a custom copier and deleter.
   *
   * The template pararameter `T` of polymorphic_value shall not be `const`
   * qualified. Otherwise the program is ill-formed.
   *
   * The template parameter `T` of `polymorphic_value` shall not be an array
   * type, a union, a function pointer or a reference type. Otherwise the
   * program is ill-formed.
   *
   * The template parameter `T` of `polymorphic_value` may be an incomplete
   * type.
   */
  template <class T>
  class polymorphic_value {
    static_assert(!std::is_array<T>::value, "");
    static_assert(!std::is_const<T>::value, "");
    static_assert(!std::is_function<T>::value, "");
    static_assert(!std::is_reference<T>::value, "");
    static_assert(!std::is_union<T>::value, "");

    template <class U>
    friend class polymorphic_value;

    template <class U, class V, class... Ts>
    friend polymorphic_value<U> make_polymorphic_value(Ts&&... ts);

    template <class U, class V, class C, class D, class>
    friend polymorphic_value<U> assume_polymorphic_value(V* p, C c, D d);

    template <class T_, class U, class>
    friend polymorphic_value<T_>
    polymorphic_value_cast(const polymorphic_value<U>& p);

    template <class T_, class U, class>
    friend polymorphic_value<T_>
    polymorphic_value_cast(polymorphic_value<U>&& p);

  public:
    using element_type = T;

    //
    // Destructor
    //

    /**
     * _Effects_: If `!bool(this)` then there are no effects. If a custom
     * deleter `d` is present then `d(p)` is called and the copier and deleter
     * are destroyed. Otherwise the destructor of the managed object is called.
     */
    ~polymorphic_value() = default;


    //
    // Constructors
    //

    /**
     * _Effects_: Constructs an empty `polymorphic_value`.
     */
    polymorphic_value() {}


    //
    // Copy-constructors
    //

    /**
     * _Effects_: Creates a `polymorphic_value` object that owns a copy of the
     * object managed by `p`. If `p` has a custom copier then the copy is
     * created by the copier in `p`. Otherwise the copy is created by copy
     * construction of the owned object.  If `p` has a custom copier and
     * deleter then the custom copier and deleter of the `polymorphic_value`
     * constructed are copied from those in `p`.
     *
     * _Throws_: Any exception thrown by the copier or `std::bad_alloc` if
     * required storage cannot be obtained.
     *
     * _Postconditions_:  `bool(*this) == bool(p)`.
     */
    polymorphic_value(const polymorphic_value& p) {
      if (!p) {
        return;
      }
      auto tmp_cb = p.cb_->clone();
      ptr_ = tmp_cb->ptr();
      cb_ = std::move(tmp_cb);
    }

    //
    // Move-constructors
    //
    //

    /**
     * _Effects_: Ownership of the resource managed by `p` is transferred to
     * the constructed `polymorphic_value`.  Potentially move constructs the
     * owned object (if the dynamic type of the owned object is no-throw
     * move-constructible).  If `p` has a custom copier and deleter then the
     * copier and deleter of the `polymorphic_value` constructed are the same as
     * those in `p`.
     *
     * _Throws_: `bad_alloc` if required storage cannot be obtained.
     *
     * _Postconditions_:  `*this` contains the old value of `p`. `p` is empty.
     */
    polymorphic_value(polymorphic_value&& p) noexcept {
      ptr_ = p.ptr_;
      cb_ = std::move(p.cb_);
      p.ptr_ = nullptr;
    }

    //
    // Assignment
    //

    /**
     * _Effects_: `*this` owns a copy of the resource managed by `p`.  If `p`
     * has a custom copier and deleter then the copy is created by the copier in
     * `p`, and the copier and deleter of `*this` are copied from those in `p`.
     * Otherwise the resource managed by `*this` is initialised by the copy
     * constructor of the resource managed by `p`.
     *
     * _Throws_: Any exception thrown by the copier or `bad_alloc` if required
     *  storage cannot be obtained.
     *
     * _Returns_: `*this`.
     *
     * _Postconditions_:  `bool(*this) == bool(p)`.
     */
    polymorphic_value& operator=(const polymorphic_value& p) {
      if (&p == this) {
        return *this;
      }

      if (!p) {
        cb_.reset();
        ptr_ = nullptr;
        return *this;
      }

      auto tmp_cb = p.cb_->clone();
      ptr_ = tmp_cb->ptr();
      cb_ = std::move(tmp_cb);
      return *this;
    }

    //
    // Move-assignment
    //

    /**
     * _Effects_: Ownership of the resource managed by `p` is transferred to
     * `this`. Potentially move constructs the owned object (if the dynamic type
     * of the owned object is no-throw move-constructible).  If `p` has a custom
     * copier and deleter then the copier and deleter of `*this` are the same as
     * those in `p`.
     *
     * _Throws_: `bad_alloc` if required storage cannot be obtained.
     *
     * _Returns_: `*this`.
     *
     * _Postconditions_: `*this` contains the old value of `p`. `p` is empty.
     */
    polymorphic_value& operator=(polymorphic_value&& p) noexcept {
      if (&p == this) {
        return *this;
      }

      cb_ = std::move(p.cb_);
      ptr_ = p.ptr_;
      p.ptr_ = nullptr;
      return *this;
    }

    //
    // Modifiers
    //

    /**
     * _Effects_: Exchanges the contents of `p` and `*this`.
     */
    void swap(polymorphic_value& p) noexcept {
      using std::swap;
      swap(ptr_, p.ptr_);
      swap(cb_, p.cb_);
    }

    //
    // Observers
    //

    /**
     * _Returns_: `false` if the `polymorphic_value` is empty, otherwise `true`.
     */
    explicit operator bool() const { return (bool)cb_; }

    /**
     * _Requires_: `bool(*this)`.
     *
     * _Returns_: A pointer to the owned object.
     */
    const T* operator->() const {
      assert(ptr_);
      return ptr_;
    }

    /**
     * _Requires_: `bool(*this)`.
     *
     *_Returns_: A pointer to the owned object.
     */
    T* operator->() {
      assert(ptr_);
      return ptr_;
    }

    /**
     * _Requires_: `bool(*this)`.
     *
     * _Returns_: A reference to the owned object.
     */
    const T& operator*() const {
      assert(ptr_);
      return *ptr_;
    }

    /**
     * _Requires_: `bool(*this)`.
     *
     * _Returns_: A reference to the owned object.
     */
    T& operator*() {
      assert(ptr_);
      return *ptr_;
    }

  private:
    T* ptr_ = nullptr;
    std::unique_ptr<detail::control_block<element_type>> cb_;

    //
    // Pointer constructor.
    //

#ifndef BOOST_POLYMORPHIC_VALUE_DOXYGEN
    template <class U, class C = default_copy<U>,
              class D = std::default_delete<U>,
              class = std::enable_if_t<std::is_base_of<T, U>::value>>
    explicit polymorphic_value(detail::private_ctor_tag_t, U* u, C copier = C{},
                               D deleter = D{}) {
      if (!u) {
        return;
      }

      if (std::is_same<D, std::default_delete<U>>::value &&
          std::is_same<C, default_copy<U>>::value && typeid(*u) != typeid(U))
        throw bad_polymorphic_value_construction();

      std::unique_ptr<U, D> p(u, std::move(deleter));

      cb_ = std::make_unique<detail::pointer_control_block<T, U, C, D>>(
          std::move(p), std::move(copier));
      ptr_ = u;
    }

    //
    // Converting constructors.
    //

    template <class U, class = std::enable_if_t<!std::is_same<T, U>::value &&
                                                std::is_base_of<T, U>::value>>
    polymorphic_value(detail::private_ctor_tag_t, const polymorphic_value<U>& p) {
      cb_ = std::make_unique<detail::delegating_control_block<T, U>>(
          p.cb_->clone());
      ptr_ = cb_->ptr();
    }

    template <class U, class = std::enable_if_t<!std::is_same<T, U>::value &&
                                                std::is_base_of<T, U>::value>>
    polymorphic_value(detail::private_ctor_tag_t, polymorphic_value<U>&& p) {
      ptr_ = p.ptr_;
      cb_ = std::make_unique<detail::delegating_control_block<T, U>>(
          std::move(p.cb_));
      p.ptr_ = nullptr;
    }

#endif // BOOST_POLYMORPHIC_VALUE_DOXYGEN
  };

  //
  // polymorphic_value creation
  //

  /**
   * _Returns_: A `polymorphic_value<T>` owning an object initialised with
   * `U(std::forward<Ts>(ts)...)`.
   */
  template <class T, class U = T, class... Ts>
  polymorphic_value<T> make_polymorphic_value(Ts&&... ts) {
    polymorphic_value<T> p;
    p.cb_ = std::make_unique<detail::direct_control_block<T, U>>(
        std::forward<Ts>(ts)...);
    p.ptr_ = p.cb_->ptr();
    return std::move(p);
  }

#ifdef BOOST_POLYMORPHIC_VALUE_DOXYGEN
  template <class T, class U, class C = default_copy<U>,
            class D = std::default_delete<U>>
#else
  template <class T, class U, class C = default_copy<U>,
            class D = std::default_delete<U>,
            class = std::enable_if_t<std::is_base_of<T, U>::value>>
#endif
  /**
   * _Remarks_: This function shall not participate in overload resolution
   * unless `std::is_base_of<T,U>::value` is true.  A custom copier and
   * deleter are said to be 'present' in a `polymorphic_value` initialized
   * with this constructor.
   *
   * _Returns_: If `p` is null, creates an empty `polymorphic_value`, otherwise
   * creates a `polymorphic_value` object that owns the object `*p`.
   *
   * If `p` is non-null then the copier and deleter of the `polymorphic_value`
   * constructed are initialized from `std::move(c)` and `std::move(d)`.
   *
   * _Requires_: `C` and `D` satisfy the requirements of CopyConstructible.
   * If `p` is non-null then the expression `c(*p)` returns an object of type
   * `U*`. The expression `d(p)` is well formed, has well defined behavior, and
   * does not throw exceptions.
   *
   * _Throws_: `bad_polymorphic_value_construction` if `is_same_v<C,
   * boost::default_copy<U>>`, `is_same_v<D, std::default_delete<U>>` and
   * `typeid(*u)!=typeid(U)`; `std::bad_alloc` if required storage cannot be
   * obtained.
   */
  polymorphic_value<T> assume_polymorphic_value(U* u, C copier = {},
                                                D deleter = {}) {
    return polymorphic_value<T>(detail::private_ctor_tag, u, std::move(copier),
                                std::move(deleter));
  }

  //
  // polymorphic_value casts
  //
#ifdef BOOST_POLYMORPHIC_VALUE_DOXYGEN
  template <class T, class U>
#else
  template <class T, class U,
            class = std::enable_if_t<std::is_base_of<T, U>::value>>
#endif
  /**
   * _Remarks_: This function shall not participate in overload
   * resolution unless `std::is_base_of<T,U>::value` is true.
   *
   * _Returns_: A `polymorphic_value` object that owns a copy of the
   * object managed by `p`. If `p` has a custom copier then the copy is
   * created by the copier in `p`. Otherwise the copy is created by copy
   * construction of the owned object.  If `p` has a custom copier and deleter
   * then the custom copier and deleter of the `polymorphic_value` constructed
   * are copied from those in `p`.
   *
   * _Throws_: Any exception thrown by the copier or by the copy-constructor of
   * the owned object, or `std::bad_alloc` if required storage cannot be
   * obtained.
   */
  polymorphic_value<T> polymorphic_value_cast(const polymorphic_value<U>& p) {
    return polymorphic_value<T>(detail::private_ctor_tag, p);
  }

#ifdef BOOST_POLYMORPHIC_VALUE_DOXYGEN
  template <class T, class U>
#else
  template <class T, class U,
            class = std::enable_if_t<!std::is_same<T, U>::value &&
                                     std::is_base_of<T, U>::value>>
#endif
  /**
   * _Remarks_: This function shall not participate in overload
   *  resolution unless `std::is_base_of<T,U>::value` is true.
   *
   * _Returns_: A `polymorphic_value` that owns the resource previously managed
   * by `p`.  Potentially move constructs the owned object (if the dynamic type
   * of the owned object is no-throw move-constructible).  If `p` has a custom
   * copier and deleter then the copier and deleter of the `polymorphic_value`
   * constructed are the same as those in `p`.
   *
   * _Throws_: `std::bad_alloc` if required storage cannot be obtained.
   *
   * _Postconditions_: `p` is empty.
   */
  polymorphic_value<T> polymorphic_value_cast(polymorphic_value<U>&& p) {
    return polymorphic_value<T>(detail::private_ctor_tag, std::move(p));
  }

  //
  // non-member swap
  //

  /**
   * _Effects_: Equivalent to `p.swap(u)`.
   */
  template <class T>
  void swap(polymorphic_value<T>& t, polymorphic_value<T>& u) noexcept {
    t.swap(u);
  }

} // namespace boost

#endif // BOOST_POLYMORPHIC_VALUE_12JUL2018_HPP
